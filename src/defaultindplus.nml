grf {
    grfid: "eF\01\01";
    name: string(STR_GRF_NAME);
    desc: string(STR_GRF_DESCRIPTION);
    version: 3;
    min_compatible_version: 1;
    param {
        // ADDITIONAL MECHANICS SEPERATOR
        param_ext_sep {
            name: string(STR_PARAM_EXT_SEPERATE);
            type: int;
            min_value: 0;
            max_value: 0;
            def_value: 0;
        }
    }

    param {
    // TEMPERATE / SUB-ARCTIC: Petroleum efficiency bonus
    param_petrol_bonus {
    name: string(STR_PARAM_PETROL_BOOST_NAME);
    desc: string(STR_PARAM_PETROL_BOOST_DESC);
    type: int;
    min_value: 0;
    max_value: 1000;
    def_value: 50;
    }
    }
    param {
    // TEMPERATE / SUB-ARCTIC: Petrol consumption rate
    param_petrol_cons {
        name: string(STR_PARAM_PETROL_CONS_NAME);
        desc: string(STR_PARAM_PETROL_CONS_DESC);
        type: int;
        min_value: 1;
        max_value: 500;
        def_value: 20;
    }
    }
    param {
        // TEMPERATE / SUB-TROPIC: Lubricant efficiency bonus
        param_lubricant_bonus {
            name: string(STR_PARAM_LUBR_BOOST_NAME);
            desc: string(STR_PARAM_LUBR_BOOST_DESC);
            type: int;
            min_value: 0;
            max_value: 1000;
            def_value: 50;
        }
    }
    param {
    // TEMPERATE / SUB_TROPIC: Lubricant consumption rate
    param_lubricant_cons {
        name: string(STR_PARAM_LUBR_CONS_NAME);
        desc: string(STR_PARAM_LUBR_CONS_DESC);
        type: int;
        min_value: 1;
        max_value: 500;
        def_value: 15;
    }
    }

    param {
        // BONUS MECHANICS SEPERATOR
        param_bon_sep {
            name: string(STR_PARAM_BON_SEPERATE);
            type: int;
            min_value: 0;
            max_value: 0;
            def_value: 0;
        }
    }

    param {
        // Power plants give a production bonus to industries.
        param_power_enabled {
            name: string(STR_PARAM_POWER_NAME);
            desc: string(STR_PARAM_POWER_DESC);
            type: int;
            min_value: 0;
            max_value: 3;
            def_value: 2;
            names: {
                0: string(STR_PARAM_BONUS_DISABLE);
                1: string(STR_PARAM_BONUS_PRIM);
                2: string(STR_PARAM_BONUS_SEC);
                3: string(STR_PARAM_BONUS_BOTH);
            };
        }
    }
    param {
        // Power plant advanced mechanics
        param_power_advanced {
            name: string(STR_PARAM_POWERADV_NAME);
            desc: string(STR_PARAM_POWERADV_DESC);
            type: bool;
            def_value: 1;
        }
    }
    param {
        // Power plant bonus soft cap?
        param_power_soft_cap {
            name: string(STR_PARAM_POWERSOFT_NAME);
            desc: string(STR_PARAM_POWERSOFT_DESC);
            type: bool;
            def_value: 0;
        }
    }
    param {
        // Power consumption rate
        param_power_cons {
            name: string(STR_PARAM_POWERCONS_NAME);
            desc: string(STR_PARAM_POWERCONS_DESC);
            type: int;
            min_value: 10;
            max_value: 2500;
            def_value: 150;
        }
    }
    param {
        // Cargo for max power bonus.
        param_power_cargo_req {
            name: string(STR_PARAM_POWERCARGO_NAME);
            desc: string(STR_PARAM_POWERCARGO_DESC);
            type: int;
            min_value: 10;
            max_value: 10000;
            def_value: 1000;
        }
    }
    param {
        // Power plant stockpiling multiplier
        param_power_stockpile_mult {
            name: string(STR_PARAM_POWER_STOCK_NAME);
            desc: string(STR_PARAM_POWER_STOCK_DESC);
            type: int;
            min_value: 1;
            max_value: 2500;
            def_value: 200;
        }
    }
    param {
        // Max power bonus.
        param_power_max_bonus {
            name: string(STR_PARAM_POWEREFF_NAME);
            desc: string(STR_PARAM_POWEREFF_DESC);
            type: int;
            min_value: 1;
            max_value: 1000;
            def_value: 100;
        }
    }
    param {
        // Banks give a production bonus to industries.
        param_bank_bonus_enabled {
            name: string(STR_PARAM_BANK_NAME);
            desc: string(STR_PARAM_BANK_DESC);
            type: int;
            min_value: 0;
            max_value: 3;
            def_value: 1;
            names: {
                0: string(STR_PARAM_BONUS_DISABLE);
                1: string(STR_PARAM_BONUS_PRIM);
                2: string(STR_PARAM_BONUS_SEC);
                3: string(STR_PARAM_BONUS_BOTH);
            };
        }
    }
    param {
        // Advanced bank rules
        param_bank_bonus_advanced {
            name: string(STR_PARAM_BANKADV_NAME);
            desc: string(STR_PARAM_BANKADV_DESC);
            type: bool;
            def_value: 1;
        }
    }
    param {
        // Bank soft cap?
        param_bank_bonus_soft_cap {
            name: string(STR_PARAM_FUNDSOFT_NAME);
            desc: string(STR_PARAM_FUNDSOFT_DESC);
            type: bool;
            def_value: 0;
        }
    }
    param {
        // Bank funding consumption rate
        param_bank_funding_cons {
            name: string(STR_PARAM_FUNDINGCONS_NAME);
            desc: string(STR_PARAM_FUNDINGCONS_DESC);
            type: int;
            def_value: 70;
            min_value: 10;
            max_value: 10000;
        }
    }
    param {
        // Needed cargo for max consumption.
        param_bank_bonus_req {
            name: string(STR_PARAM_BANKCARGO_NAME);
            desc: string(STR_PARAM_BANKCARGO_DESC);
            type: int;
            min_value: 10;
            max_value: 10000;
            def_value: 300;
        }
    }
    param {
        // Bank stockpiling multiplier
        param_bank_stockpile_mult {
            name: string(STR_PARAM_BANK_STOCK_NAME);
            desc: string(STR_PARAM_BANK_STOCK_DESC);
            type: int;
            min_value: 1;
            max_value: 2500;
            def_value: 350;
        }
    }
    param {
        // Maximum bank bonus.
        param_bank_max_bonus {
            name: string(STR_PARAM_BANKEFF_NAME);
            desc: string(STR_PARAM_BANKEFF_DESC);
            type: int;
            min_value: 1;
            max_value: 1000;
            def_value: 100;
        }
    }

    param {
        // Town population provides a production bonus to industries.
        param_town_bonus_enabled {
            name: string(STR_PARAM_TOWN_NAME);
            desc: string(STR_PARAM_TOWN_DESC);
            type: int;
            min_value: 0;
            max_value: 3;
            def_value: 3;
            names: {
                0: string(STR_PARAM_BONUS_DISABLE);
                1: string(STR_PARAM_BONUS_PRIM);
                2: string(STR_PARAM_BONUS_SEC);
                3: string(STR_PARAM_BONUS_BOTH);
            };
        }
    }
    param {
        // Needed pop for max town bonus.
        param_town_pop_req {
            name: string(STR_PARAM_TOWNREQ_NAME);
            desc: string(STR_PARAM_TOWNREQ_DESC);
            type: int;
            min_value: 1200;
            max_value: 32000;
            def_value: 15000;
        }
    }
    param {
        // Maximum town production bonus
        param_town_max_bonus {
            name: string(STR_PARAM_TOWNEFF_NAME);
            desc: string(STR_PARAM_TOWNEFF_DESC);
            type: int;
            min_value: 1;
            max_value: 1000;
            def_value: 35;
        }
    }
    param {
        // TEMPERATE: Bonus amplification for temperate bank production.
        param_temp_bank_town_bonus_mult {
            name: string(STR_PARAM_BANKMULT_NAME);
            desc: string(STR_PARAM_BANKMULT_DESC);
            type: int;
            min_value: 10;
            max_value: 5000;
            def_value: 500;
        }
    }

    param {
        // Multiplicative bonuses?
        param_mult_bonuses {
            name: string(STR_PARAM_BONUS_MULT_NAME);
            desc: string(STR_PARAM_BONUS_MULT_DESC);
            type: bool;
            def_value: 1;
        }
    }

    param {
        // PRIMARY OPTIONS SEPERATOR
        param_prim_sep {
            name: string(STR_PARAM_PRIM_SEPERATE);
            type: int;
            min_value: 0;
            max_value: 0;
            def_value: 0;
        }
    }

    param {
        // Primary industry closure rules
        param_prim_closure_rules {
            name: string(STR_PARAM_PRIM_CLOSE_NAME);
            desc: string(STR_PARAM_PRIM_CLOSE_DESC);
            type: int;
        min_value: 0;
        max_value: 3;
            def_value: 3;
        names: {
        0: string(STR_PARAM_PRIM_CLOSE_ALL);
        1: string(STR_PARAM_PRIM_CLOSE_SER);
        2: string(STR_PARAM_PRIM_CLOSE_UNSER);
        3: string(STR_PARAM_PRIM_CLOSE_NONE);
        };
        }
    }
    param {
        // Smooth primary industry growth?
        param_smooth_prim_growth {
            name: string(STR_PARAM_GROW_NAME);
            desc: string(STR_PARAM_GROW_DESC);
            type: bool;
            def_value: 1;
        }
    }
    param {
        // Primary industry growth difficulty
        param_prim_growth_diff {
            name: string(STR_PARAM_GROW_DIFF_NAME);
            desc: string(STR_PARAM_GROW_DIFF_DESC);
            type: int;
            min_value: 0;
            max_value: 2;
            def_value: 1;
            names: {
                0: string(STR_PARAM_DIFF_EASY);
                1: string(STR_PARAM_DIFF_NORM);
                2: string(STR_PARAM_DIFF_HARD);
            };
        }
    }
    param {
    // Unserviced industry freezing
    param_prim_unserviced_freeze {
        name: string(STR_PARAM_PRIM_FREEZE_NAME);
        desc: string(STR_PARAM_PRIM_FREEZE_DESC);
        type: int;
        min_value: 0;
        max_value: 3;
        def_value: 3;
        names: {
        0: string(STR_PARAM_PRIM_FREEZE_DIS);
        1: string(STR_PARAM_PRIM_FREEZE_VAN);
        2: string(STR_PARAM_PRIM_FREEZE_LOW);
        3: string(STR_PARAM_PRIM_FREEZE_NONE);
        };
    }
    }
    param {
        // Probability that primaries will increase
        param_prim_change_chance {
            name: string(STR_PARAM_PRIM_PROB_NAME);
            desc: string(STR_PARAM_PRIM_PROB_DESC);
            type: int;
            min_value: 1;
            max_value: 128;
            def_value: 14;
        }
    }
    param {
        // Extractive industry reserves?
        param_extract_reserves {
            name: string(STR_PARAM_EXRESERVES_NAME);
            desc: string(STR_PARAM_EXRESERVES_DESC);
            type: bool;
            def_value: 0;
        }
    }
    param {
        // Organic industry reserves?
        param_organic_reserves {
            name: string(STR_PARAM_ORRESERVES_NAME);
            desc: string(STR_PARAM_ORRESERVES_DESC);
            type: bool;
            def_value: 0;
        }
    }
    param {
        // Industry reserve size
        param_reserve_size {
            name: string(STR_PARAM_RESERVESIZE_NAME);
            desc: string(STR_PARAM_RESERVESIZE_DESC);
            type: int;
            min_value: 5;
            max_value: 10000;
            def_value: 100;
        }
    }
    param {
    // Primary production rate
    param_prim_prod_rate {
        name: string(STR_PARAM_TOTAL_PROD_NAME);
        desc: string(STR_PARAM_TOTAL_PROD_DESC);
        type: int;
        min_value: 10;
        max_value: 10000;
        def_value: 100;
    }
    }

    param {
        // SECONDARY MECHANICS SEPERATOR
        param_sec_sep {
            name: string(STR_PARAM_SEC_SEPERATE);
            type: int;
            min_value: 0;
            max_value: 0;
            def_value: 0;
        }
    }
    param {
    param_sec_closures {
        name: string(STR_PARAM_SEC_CLOSE_NAME);
        desc: string(STR_PARAM_SEC_CLOSE_DESC);
        type: int;
        min_value: 0;
        max_value: 3;
        def_value: 2;
        names: {
        0: string(STR_PARAM_SEC_CLOSE_ALL);
        1: string(STR_PARAM_SEC_CLOSE_SER);
        2: string(STR_PARAM_SEC_CLOSE_UNSER);
        3: string(STR_PARAM_SEC_CLOSE_NONE);
        };
    }
    }
    param {
    // Advanced secondary mechanics?
    param_sec_advanced {
        name: string(STR_PARAM_ADV_SEC_NAME);
        desc: string(STR_PARAM_ADV_SEC_DESC);
        type: bool;
        def_value: 1;
    }
    }
    param {
        // Secondary growth difficulty
        param_sec_growth_diff {
            name: string(STR_PARAM_GROW_SEC_NAME);
            desc: string(STR_PARAM_GROW_SEC_DESC);
            type: int;
            min_value: 0;
            max_value: 2;
            def_value: 1;
        names:
        {
            0: string(STR_PARAM_DIFF_EASY);
        1: string(STR_PARAM_DIFF_NORM);
        2: string(STR_PARAM_DIFF_HARD);
        };
        }
    }
    param {
    param_sec_unserviced_freeze {
        name: string(STR_PARAM_FREEZE_SEC_NAME);
        desc: string(STR_PARAM_FREEZE_SEC_DESC);
        type: int;
        min_value: 0;
        max_value: 3;
        def_value: 3;
        names:
        {
        0: string(STR_PARAM_SEC_FREEZE_DIS);
        1: string(STR_PARAM_SEC_FREEZE_VAN);
        2: string(STR_PARAM_SEC_FREEZE_LOW);
        3: string(STR_PARAM_SEC_FREEZE_NONE);
        };
    }
    }
    param {
        // Secondary growth probability
    param_sec_grow_prob {
        name: string(STR_PARAM_SECGROWPROB_NAME);
        desc: string(STR_PARAM_SECGROWPROB_DESC);
        type: int;
        min_value: 0;
        max_value: 128;
        def_value: 10;
    }
}
    param {
        // Secondaries need power?
        param_sec_power_need {
            name: string(STR_PARAM_POWERREQ_NAME);
            desc: string(STR_PARAM_POWERREQ_DESC);
            type: bool;
            def_value: 0;
        }
    }
    param {
        // Maximum secondary industry consumption %.
        param_sec_max_consumption {
            name: string(STR_PARAM_SECINDCONS_NAME);
            desc: string(STR_PARAM_SECINDCONS_DESC);
            type: int;
            min_value: 10;
            max_value: 10000;
            def_value: 100;
        }
    }
    param {
        // % of extra cargo for maximum secondary consumption.
        param_sec_max_stockpile_perc {
            name: string(STR_PARAM_STOCKMULT_NAME);
            desc: string(STR_PARAM_STOCKMULT_DESC);
            type: int;
            min_value: 100;
            max_value: 2000;
            def_value: 200;
        }
    }

    param {
        // VISUAL OPTIONS SEPERATOR
        param_qol_sep {
            name: string(STR_PARAM_QOL_SEPERATE);
            type: int;
            min_value: 0;
            max_value: 0;
            def_value: 0;
        }
    }
    param {
        // Detailed info enabled?
        param_ind_detailed_enabled {
            name: string(STR_PARAM_DETAILED_NAME);
            desc: string(STR_PARAM_DETAILED_DESC);
            type: int;
            min_value: 0;
            max_value: 3;
            def_value: 1;
            names: {
                0: string(STR_PARAM_DETAILED_NONE);
                1: string(STR_PARAM_DETAILED_BONUS);
                2: string(STR_PARAM_DETAILED_RES);
                3: string(STR_PARAM_DETAILED_BOTH);
            };
        }
    }
    param {
    // Tips enabled?
    param_tips_enabled {
        name: string(STR_PARAM_TIPS_NAME);
        desc: string(STR_PARAM_TIPS_DESC);
        type: bool;
        def_value: 1;
    }
    }
}

cargotable {
    "PASS", "COAL", "MAIL", "OIL_", "LVST", "GOOD", "GRAI", "WOOD", "IORE", "STEL", "VALU",
    "PAPR", "WHEA", "FOOD", "GOLD", "RUBR", "FRUT", "MAIZ", "CORE", "WATR", "DIAM", "SUGR",
    "LMBR", "LUBR", "PETR"
}

item(FEAT_CARGOS, cargo_lumber, 22) {
    property {
    number: 22;
    type_name: string(STR_LUMBER_NAME);
    unit_name: string(STR_LUMBER_NAME);
    units_of_cargo: TTD_STR_TONS;
    items_of_cargo: string(STR_LUMBER_LONG);
    type_abbreviation: string(STR_LUMBER_ABBREV);
    sprite: 4307;
    weight: 1;
    is_freight: 1;
    cargo_classes: bitmask(CC_PIECE_GOODS);
    cargo_label: "LMBR";
    town_growth_effect: TOWNGROWTH_NONE;
    town_growth_multiplier: 1.0;
    penalty_lowerbound: 18;
    single_penalty_length: 255;
    station_list_colour: 58;
    cargo_payment_list_colour: 58;
    price_factor: 123;
    capacity_multiplier: 1;
    }
}

item(FEAT_CARGOS, cargo_lubricant, 23) {
    property {
        number: 23;
    type_name: string(STR_LUBRICANT_NAME);
    unit_name: string(STR_LUBRICANT_NAME);
    units_of_cargo: TTD_STR_LITERS;
    items_of_cargo: string(STR_LUBRICANT_LONG);
    type_abbreviation: string(STR_LUBRICANT_ABBREV);
    sprite: 4300;
    weight: 1;
    is_freight: 1;
    cargo_classes: bitmask(CC_LIQUID);
    cargo_label: "LUBR";
    town_growth_effect: TOWNGROWTH_NONE;
    town_growth_multiplier: 1.0;
    penalty_lowerbound: 18;
    single_penalty_length: 255;
    station_list_colour: 140;
    cargo_payment_list_colour: 140;
    price_factor: 97;
    capacity_multiplier: 1;
    }
}

item(FEAT_CARGOS, cargo_petrol, 24) {
    property {
    number: 24;
    type_name: string(STR_PETROL_NAME);
    unit_name: string(STR_PETROL_NAME);
    units_of_cargo: TTD_STR_LITERS;
    items_of_cargo: string(STR_PETROL_LONG);
    type_abbreviation: string(STR_PETROL_ABBREV);
    sprite: 4300;
    weight: 1;
    is_freight: 1;
    cargo_classes: bitmask(CC_LIQUID);
    cargo_label: "PETR";
    town_growth_effect: TOWNGROWTH_NONE;
    town_growth_multiplier: 1.0;
    penalty_lowerbound: 18;
    single_penalty_length: 255;
    station_list_colour: 182;
    cargo_payment_list_colour: 182;
    price_factor: 127;
    capacity_multiplier: 1;
    }
}

// Global Functions

// Returns the base production of an industry
switch(FEAT_INDUSTRIES, SELF, GetBaseProduction, production_level) {return;}

// Returns the base production as a percent: 64 is 50%, for example.
switch(FEAT_INDUSTRIES, SELF, GetBaseProductionPerc, (production_level*100)/128) {return;}

// Returns the population of the town.
switch(FEAT_INDUSTRIES, PARENT, GetTownPopulation, min(population,32000)) {return;}

// Get the production bonus that the town population provides.
switch(FEAT_INDUSTRIES, SELF, GetTownProductionBonus, param_town_bonus_enabled ? min((GetTownPopulation()*param_town_max_bonus/param_town_pop_req),param_town_max_bonus) : 0x00) {return;}

// Get the production bonus that the power plant provides.
switch(FEAT_INDUSTRIES, PARENT, GetPowerProductionBonus, LOAD_PERM(0)) {return;}

// Get the production bonus that the bank provides.
switch(FEAT_INDUSTRIES, PARENT, GetBankProductionBonus, LOAD_PERM(1)) {return;}

// Industry functions

// Returns total primary production, after all applicable bonuses.
switch(FEAT_INDUSTRIES, SELF, GetTotalPrimaryProduction, param_mult_bonuses ?
    (((param_prim_prod_rate*production_level*(((GetPowerProductionBonus()*hasbit(param_power_enabled,0)))+100))/100*((GetBankProductionBonus()*hasbit(param_bank_bonus_enabled,0))+100))/100*((GetTownProductionBonus()*hasbit(param_town_bonus_enabled,0))+100))/10000
  : (production_level*param_prim_prod_rate*((GetPowerProductionBonus()*hasbit(param_power_enabled,0))+(GetTownProductionBonus()*hasbit(param_town_bonus_enabled,0))+(GetBankProductionBonus()*hasbit(param_bank_bonus_enabled,0))+100))/10000) {return;}

// Returns the theoretical maximum primary production
switch(FEAT_INDUSTRIES, SELF, GetMaxPrimaryProduction, param_mult_bonuses ?
    (((128*param_prim_prod_rate*(((param_power_max_bonus*hasbit(param_power_enabled,0)))+100))/100*((param_bank_max_bonus*hasbit(param_bank_bonus_enabled,0))+100))/100*((param_town_max_bonus*hasbit(param_town_bonus_enabled,0))+100))/10000
  : ((128*param_prim_prod_rate*(100+((param_power_max_bonus)*hasbit(param_power_enabled,0))+(param_bank_max_bonus*hasbit(param_bank_bonus_enabled,0))+(param_town_max_bonus*hasbit(param_town_bonus_enabled,0))))/10000))
{return;}

switch(FEAT_INDUSTRIES, SELF, GetMaxBaseConversion, param_sec_advanced ? 128 : 64) {return;}

switch(FEAT_INDUSTRIES, SELF, GetBaseConversion, param_sec_advanced ? production_level : 64) {return;}

// Returns the theoretical maximum secondary production
switch(FEAT_INDUSTRIES, SELF, GetMaxSecondaryProduction, param_mult_bonuses ?
    (((param_sec_max_consumption*GetMaxBaseConversion()*(((param_power_max_bonus*hasbit(param_power_enabled,1)))+100))/100*((param_bank_max_bonus*hasbit(param_bank_bonus_enabled,1))+100))/100*((param_town_max_bonus*hasbit(param_town_bonus_enabled,1))+100))/10000
  : ((param_sec_max_consumption*128*(100+((param_power_max_bonus)*hasbit(param_power_enabled,1))+(param_bank_max_bonus*hasbit(param_bank_bonus_enabled,1))+(param_town_max_bonus*hasbit(param_town_bonus_enabled,1))))/10000))
{return;}

// We rely on the industry to calculate its own stockpile modifier and store it in perm register 0
switch(FEAT_INDUSTRIES, SELF, GetStockpileModifier, LOAD_PERM(0)) {return;}

// Returns total secondary production, after all applicable bonuses.
switch(FEAT_INDUSTRIES, SELF, GetTotalSecondaryProduction, param_mult_bonuses ?
    (((param_sec_max_consumption*((GetBaseConversion()*GetStockpileModifier())/100)*(((GetPowerProductionBonus()*hasbit(param_power_enabled,1)))+100))/100*((GetBankProductionBonus()*hasbit(param_bank_bonus_enabled,1))+100))/100*((GetTownProductionBonus()*hasbit(param_town_bonus_enabled,1))+100))/10000
  : (param_sec_max_consumption*GetBaseConversion()*((GetPowerProductionBonus()*hasbit(param_power_enabled,1))+(GetTownProductionBonus()*hasbit(param_town_bonus_enabled,1))+(GetBankProductionBonus()*hasbit(param_bank_bonus_enabled,1))+100))/10000) {return;}

// Returns the secondary production as a percentage
switch(FEAT_INDUSTRIES, SELF, GetSecondaryProductionPerc, (GetTotalSecondaryProduction()*100)/GetMaxSecondaryProduction()) {return;}

// Returns the percentage of reserves remaining 
switch(FEAT_INDUSTRIES, SELF, GetReservesPerc, max((LOAD_PERM(1)*100)/(LOAD_PERM(2)),0)) {return;}

// Deplete reserves when doing a production event
switch(FEAT_INDUSTRIES, SELF, LowerReserves, STORE_PERM(LOAD_PERM(1)-GetTotalPrimaryProduction(),1)) {return;}

// Returns the production of a primary as a percentage.
switch(FEAT_INDUSTRIES, SELF, GetPrimaryProductionPerc, (GetTotalPrimaryProduction()*100)/GetMaxPrimaryProduction()) {return;}

// Get the power consumption of primary industries if they're active and they have a production tick
switch(FEAT_INDUSTRIES, PARENT, GetPowerConsumption, min(GetBaseProduction()*param_power_cons/100,LOAD_PERM(5))) {return;}

// Get the power consumption of secondary industries if they're active and they have a production tick
switch(FEAT_INDUSTRIES, PARENT, GetPowerConsumptionSec, min(GetBaseConversion()*GetStockpileModifier()*param_power_cons/10000,LOAD_PERM(5))) {return;}

// Get the funding consumption of industries if they're active and they have a production tick
switch(FEAT_INDUSTRIES, PARENT, GetFundingConsumption, min(GetBaseProduction()*param_bank_funding_cons/100,LOAD_PERM(6))) {return;}

// Get the funding consumption of secondary industries if they're active and they have a production tick
switch(FEAT_INDUSTRIES, PARENT, GetFundingConsumptionSec, min(GetBaseConversion()*GetStockpileModifier()*param_bank_funding_cons/10000,LOAD_PERM(6))) {return;}

// Returns units of bank funding, if advanced bank bonus is enabled.
switch(FEAT_INDUSTRIES, PARENT, GetBankFunding, STORE_TEMP(min(param_bank_bonus_advanced ? LOAD_PERM(6) : 0x00,20000000),1)) {return LOAD_TEMP(1);}

// Returns units of power, if advanced bank bonus is enabled.
switch(FEAT_INDUSTRIES, PARENT, GetPowerUnits, STORE_TEMP(min(param_power_advanced ? LOAD_PERM(5) : 0x00,20000000),1)) {return LOAD_TEMP(1);}

// Returns 1 if secondary has power and/or doesn't require it, 0 if it does require it and doesn't have it.
switch(FEAT_INDUSTRIES, SELF, IsSecondaryPowered, (param_sec_power_need ? GetPowerProductionBonus() > (param_power_max_bonus/4) : 0x01)) {return;}

// This is a hell of a function since almost all of these features need to be completely decoupled yet still work together properly in this menu. If statements don't accomplish the logic I'd like, and switch statements seem to lose all local context in the store_temp vars when progressing back down the call stack so all of this is done with ternary operators. sorry...
switch(FEAT_INDUSTRIES, SELF, switch_production_display_primary_composite, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP((hasbit(param_power_enabled,0) && hasbit(param_ind_detailed_enabled,0)) ? ((param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4) ? string(STR_IND_PRIM_PROD_POWERT) : string(STR_IND_PRIM_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,0) && hasbit(param_ind_detailed_enabled,0)) ? ((param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4) ? string(STR_IND_PRIM_PROD_BANKT) : string(STR_IND_PRIM_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_town_bonus_enabled,0) && hasbit(param_ind_detailed_enabled,0)) ? ((param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5) ? string(STR_IND_PRIM_PROD_TOWNT) : string(STR_IND_PRIM_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP(GetPrimaryProductionPerc() | (param_extract_reserves == 1 ? (hasbit(param_ind_detailed_enabled,1) ? string(STR_IND_PRIM_PROD_RESERVE1) : string(STR_IND_PRIM_PROD_RESERVE2)) : string(STR_SKIP)) << 16,260),
    // If detailed reserves are disabled, show a different text that gives a vague idea of how much reserves are depleted.
    STORE_TEMP((param_extract_reserves == 1 ? (hasbit(param_ind_detailed_enabled,1) ? GetReservesPerc() :
    (((GetReservesPerc() < 13) * string(STR_IND_RESERVES_1)) +
    ((GetReservesPerc() >= 13 && GetReservesPerc() < 25) * string(STR_IND_RESERVES_2)) +
    ((GetReservesPerc() >= 25 && GetReservesPerc() < 37) * string(STR_IND_RESERVES_3)) +
    ((GetReservesPerc() >= 37 && GetReservesPerc() < 50) * string(STR_IND_RESERVES_4)) +
    ((GetReservesPerc() >= 50 && GetReservesPerc() < 63) * string(STR_IND_RESERVES_5)) +
    ((GetReservesPerc() >= 63 && GetReservesPerc() < 75) * string(STR_IND_RESERVES_6)) +
    ((GetReservesPerc() >= 75 && GetReservesPerc() < 88) * string(STR_IND_RESERVES_7)) +
    ((GetReservesPerc() >= 88) * string(STR_IND_RESERVES_8)))) : string(STR_EMPTY)),261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_TEMP((param_tips_enabled && GetBaseProductionPerc() < 25 ? string(STR_IND_PRIM_PROD_BASET) : string(STR_IND_PRIM_PROD_BASE)) | GetBaseProductionPerc() << 16,1),
    STORE_TEMP(LOAD_TEMP(1),256)                                                                                                                                               
    ]) {
    return string(STR_IND_PRIM_PROD_TOTAL);
}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_secondary_composite, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    STORE_TEMP(GetSecondaryProductionPerc(),261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)
    ]) {
    return string(STR_IND_SEC_PROD_TOTAL);
}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_secondary_composite_tips, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    STORE_TEMP(GetSecondaryProductionPerc(),261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)
    ]) {
    return string(STR_IND_SEC_PROD_TOTALT);
}

// Determines the initial production of the coal mine.
random_switch(FEAT_INDUSTRIES, SELF, random_initial_production) {
    1: return 4;
    4: return 6;
    6: return 8;
    8: return 12;
    6: return 16;
    3: return 20;
    1: return 24;
}

// Below three functions determine production changes based on difficulty, assuming smooth industry growth is enabled.
switch(FEAT_INDUSTRIES, SELF, switch_production_change_easy, LOAD_TEMP(0)) {
    0..25: return (hasbit(param_prim_closure_rules,LOAD_TEMP(1)) && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    26..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_normal, LOAD_TEMP(0)) {
    0..35: return (hasbit(param_prim_closure_rules,LOAD_TEMP(1))  && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    36..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_hard, LOAD_TEMP(0)) {
    0..45: return (hasbit(param_prim_closure_rules,LOAD_TEMP(1)) && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    46..85: return CB_RESULT_IND_PROD_NO_CHANGE;
    86..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

// These change production changes for secondary industries, assuming advanced secondaries is enabled.
switch(FEAT_INDUSTRIES, SELF, switch_production_change_sec_easy, LOAD_TEMP(0)) {
    0..25: return (hasbit(param_sec_closures,LOAD_TEMP(1)) && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    26..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_sec_normal, LOAD_TEMP(0)) {
    0..35: return (hasbit(param_sec_closures,LOAD_TEMP(1)) && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    36..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_sec_hard, LOAD_TEMP(0)) {
    0..45: return (hasbit(param_sec_closures,LOAD_TEMP(1)) && production_level == 4) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    46..85: return CB_RESULT_IND_PROD_NO_CHANGE;
    86..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

// This set is exclusively for the temperate bank since it has the quirk of never being able to close, while still acting like a primary/secondary blended into one. It also has a higher minimum production value of 8 rather than 4.
switch(FEAT_INDUSTRIES, SELF, switch_production_change_spec_easy, LOAD_TEMP(0)) {
    0..25: return (production_level == 8) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    26..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_spec_normal, LOAD_TEMP(0)) {
    0..35: return (production_level == 8) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    36..70: return CB_RESULT_IND_PROD_NO_CHANGE;
    71..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_spec_hard, LOAD_TEMP(0)) {
    0..45: return (production_level == 8) ? CB_RESULT_IND_PROD_NO_CHANGE : CB_RESULT_IND_PROD_DECREMENT_BY_1;
    46..85: return CB_RESULT_IND_PROD_NO_CHANGE;
    86..100: return CB_RESULT_IND_PROD_INCREMENT_BY_1;
}


/* COAL MINE */

/* If coal mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, coal_mine_is_active, (last_month_transported("COAL") > 0)) {return;}

// Determines the initial production of the coal mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_coal_mine, param_extract_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_coal_mine, [STORE_TEMP(transported_last_month_pct("COAL"),0),STORE_TEMP(coal_mine_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (coal_mine_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (coal_mine_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(coal_mine_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_extract_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

// This is part of a long chain leading from switch_production_coal_mine, just so that additional logic can occur every production event.
produce (produce_coal_mine,
    [],
    [COAL: LOAD_TEMP(0);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_coal_mine,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(coal_mine_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(coal_mine_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     param_extract_reserves == 1 && coal_mine_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_coal_mine;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, coal_mine, INDUSTRYTYPE_COAL_MINE) {
    property {
        substitute: INDUSTRYTYPE_COAL_MINE;
        override: INDUSTRYTYPE_COAL_MINE;
        cargo_types: [
            produce_cargo("COAL", 0)
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_coal_mine;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_coal_mine;
        build_prod_change: rand_init_coal_mine;
    }
}

/* IRON MINE */

/* If iron mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, iron_mine_is_active, (last_month_transported("IORE") > 0)) {return;}

// Determines the initial production of the iron mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_iron_mine, param_extract_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_iron_mine, [STORE_TEMP(transported_last_month_pct("IORE"),0),STORE_TEMP(iron_mine_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (iron_mine_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (iron_mine_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(iron_mine_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_extract_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

produce (produce_iron_mine,
    [],
    [IORE: LOAD_TEMP(0);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_iron_mine,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(iron_mine_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(iron_mine_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     param_extract_reserves == 1 && iron_mine_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_iron_mine;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, iron_mine, INDUSTRYTYPE_IRON_ORE_MINE) {
    property {
        substitute: INDUSTRYTYPE_IRON_ORE_MINE;
        override: INDUSTRYTYPE_IRON_ORE_MINE;
        cargo_types: [
            produce_cargo("IORE", 0)
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_iron_mine;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_iron_mine;
        build_prod_change: rand_init_iron_mine;
    }
}

/* FOREST */

/* If iron mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, forest_is_active, (last_month_transported("WOOD") > 0)) {return;}

// Determines the initial production of the iron mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_forest, param_organic_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_forest, [STORE_TEMP(transported_last_month_pct("WOOD"),0),STORE_TEMP(forest_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (forest_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (forest_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(forest_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_organic_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

produce (produce_forest,
    [],
    [WOOD: LOAD_TEMP(0);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_forest,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(forest_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(forest_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     param_extract_reserves == 1 && forest_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_forest;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, forest, INDUSTRYTYPE_FOREST) {
    property {
        substitute: INDUSTRYTYPE_FOREST;
        override: INDUSTRYTYPE_FOREST;
        cargo_types: [
            produce_cargo("WOOD", 0)
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_forest;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_forest;
        build_prod_change: rand_init_forest;
    }
}

/* OIL WELLS */

/* If iron mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, oil_wells_is_active, (last_month_transported("OIL_") > 0)) {return;}

// Determines the initial production of the iron mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_oil_wells, param_extract_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_oil_wells, [STORE_TEMP(transported_last_month_pct("OIL_"),0),STORE_TEMP(oil_wells_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (oil_wells_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (oil_wells_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(oil_wells_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_extract_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

produce (produce_oil_wells,
    [],
    [OIL_: LOAD_TEMP(0);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_oil_wells,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(oil_wells_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(oil_wells_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     param_extract_reserves == 1 && oil_wells_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_oil_wells;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, oil_wells, INDUSTRYTYPE_OIL_WELLS) {
    property {
        substitute: INDUSTRYTYPE_OIL_WELLS;
        override: INDUSTRYTYPE_OIL_WELLS;
        cargo_types: [
            produce_cargo("OIL_", 0)
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_oil_wells;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_oil_wells;
        build_prod_change: rand_init_oil_wells;
    }
}

/* FARM */

/* If iron mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, farm_is_active, (last_month_transported("LVST") + last_month_transported("GRAI") > 0)) {return;}

// Determines the initial production of the iron mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_farm, param_organic_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_farm, [STORE_TEMP((transported_last_month_pct("LVST")/2)+(transported_last_month_pct("GRAI")/2),0),STORE_TEMP(farm_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (farm_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (farm_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(farm_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_organic_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

produce (produce_farm,
    [],
    [LVST: LOAD_TEMP(0); GRAI: LOAD_TEMP(0);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_farm,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(farm_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(farm_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     param_organic_reserves == 1 && farm_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_farm;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, farm, INDUSTRYTYPE_TEMPERATE_ARCTIC_FARM) {
    property {
        substitute: INDUSTRYTYPE_TEMPERATE_ARCTIC_FARM;
        override: INDUSTRYTYPE_TEMPERATE_ARCTIC_FARM;
        cargo_types: [
            produce_cargo("LVST", 0),
        produce_cargo("GRAI", 0)
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_farm;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_farm;
        build_prod_change: rand_init_farm;
    }
}

/* OIL RIG */
// Pax/mail production is clamped between 8 units per tick (64/72 per month) and 32 units per tick (256/288 per month). Based partly on base production, but not exact.

/* If iron mine isn't active, it won't consume funding or power. */
switch(FEAT_INDUSTRIES, SELF, oil_rig_is_active, (last_month_transported("OIL_") > 0)) {return;}

// Determines the initial production of the iron mine, adding reserves if eligible
switch(FEAT_INDUSTRIES, SELF, rand_init_oil_rig, param_extract_reserves == 1 ? STORE_PERM(STORE_PERM((128+getbits(random_bits, 0, 7))*2048*param_reserve_size/100,1),2) : 0x00) {random_initial_production;}

/* Production change logic. */
switch(FEAT_INDUSTRIES, SELF, switch_production_change_oil_rig, [STORE_TEMP(transported_last_month_pct("OIL_"),0),STORE_TEMP(oil_rig_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_prim_unserviced_freeze == 3 && (oil_rig_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)*(((param_prim_unserviced_freeze >= 1) && (oil_rig_is_active() == 0))+(1+(hasbit(param_prim_unserviced_freeze,1)*(oil_rig_is_active() == 0))))) ? ((param_smooth_prim_growth == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_prim_growth_diff == 0) ? switch_production_change_easy() : ((param_prim_growth_diff == 1) ? switch_production_change_normal() : switch_production_change_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_RANDOM)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : (LOAD_PERM(1) < 0 && param_extract_reserves) ? CB_RESULT_IND_PROD_CLOSE : CB_RESULT_IND_PROD_NO_CHANGE;
}

produce (produce_oil_rig,
    [],
    [OIL_: LOAD_TEMP(0); PASS: LOAD_TEMP(1); MAIL: LOAD_TEMP(1);],
    0
)

// Does some logic before doing a production event.
switch(FEAT_INDUSTRIES, PARENT, switch_production_oil_rig,
    // Consume funding if enabled and the industry benefits from it.
    [param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(oil_rig_is_active() ? (hasbit(param_bank_bonus_enabled,0)*GetFundingConsumption()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(oil_rig_is_active() ? (hasbit(param_power_enabled,0)*GetPowerConsumption()) : 0x00),5)) : 0x00,
     STORE_TEMP(GetTotalPrimaryProduction(),0),
     STORE_TEMP(min(max(GetBaseProduction(),8),32),1),
     param_extract_reserves == 1 && oil_rig_is_active() == 1 ? LowerReserves() : 0x00,
    ])
    {produce_oil_rig;}

// Main block that defines the item. Down here to ensure all functions are defined when needed.
item(FEAT_INDUSTRIES, oil_rig, INDUSTRYTYPE_OIL_RIG) {
    property {
        substitute: INDUSTRYTYPE_OIL_RIG;
        override: INDUSTRYTYPE_OIL_RIG;
        cargo_types: [
            produce_cargo("OIL_", 0),
        produce_cargo("PASS", 0),
        produce_cargo("MAIL", 0),
        accept_cargo("PASS"),
        accept_cargo("MAIL")
        ];
    }

    graphics {
    cargo_subtype_display: CB_RESULT_IND_NO_TEXT_NO_AMOUNT;
        extra_text_industry: switch_production_display_primary_composite;
        produce_256_ticks: switch_production_oil_rig;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_oil_rig;
        build_prod_change: rand_init_oil_rig;
    }
}

/* TEMPERATE BANK */

// Leads from switch_produce_temperate_bank, so the temp values are from there.
produce (produce_temperate_bank,
    [VALU: LOAD_TEMP(0);],
    [VALU: LOAD_TEMP(3);],
    0
)

// Determines consumption. Consumption is based off waiting cargo.
switch(FEAT_INDUSTRIES, SELF, GetBankConsumption, max((min((incoming_cargo_waiting("VALU")*10000)/(param_bank_bonus_req*param_bank_stockpile_mult),100)*param_bank_bonus_req/100/8),(incoming_cargo_waiting("VALU") > 0))) {return;}

switch(FEAT_INDUSTRIES, SELF, GetBankStockpile, (param_bank_bonus_req*param_bank_stockpile_mult)/100) {return;}

// Determines bank bonus. It's based off either funding consumption or waiting cargo, based on whether you have advanced bank mechanics or not. 
switch(FEAT_INDUSTRIES, SELF, GetBankBonus, param_bank_bonus_enabled > 0 ?
    param_bank_bonus_advanced ? ((param_bank_bonus_soft_cap == 1) && (STORE_TEMP(LOAD_TEMP(1),1) > (((param_bank_bonus_req*param_bank_stockpile_mult)/100))) ?
    (STORE_TEMP(LOAD_TEMP(1),1)/(200000/5)):0x00)+min(((STORE_TEMP(LOAD_TEMP(1),1)*100/param_bank_bonus_req*100/param_bank_stockpile_mult)*param_bank_max_bonus)/100,param_bank_max_bonus) : ((incoming_cargo_waiting("VALU")*10000)/(param_bank_bonus_req*param_bank_stockpile_mult)*param_bank_max_bonus)/100 :
    0x00)
{return;}

switch(FEAT_INDUSTRIES, SELF, bank_is_active, (last_month_transported("VALU") > 0)) {return;}

// IIRC this is seperated so that the parent function GetBankFunding() can be accessed. Honestly I don't remember
switch(FEAT_INDUSTRIES, PARENT, BankBonus, GetBankFunding()) {GetBankBonus;}

// Like the primary industry display, this is complicated.
switch(FEAT_INDUSTRIES, SELF, switch_production_display_temp_bank, [
    STORE_TEMP(BankBonus() | (param_bank_bonus_enabled > 0 ?                                                             // Shows the current bonus provided by the bank.
    (param_bank_bonus_enabled == 1 ? string(STR_IND_SEC_BONUS_PRIM) : (param_bank_bonus_enabled == 2 ?
    string(STR_IND_SEC_BONUS_SEC) : string(STR_EMPTY))): string(STR_EMPTY)) << 16, 257),                                    // Bank bonus display (either primary, secondary, or none)
    STORE_TEMP((param_bank_bonus_advanced ? string(STR_IND_SEC_BANK_STOCK) : string(STR_SKIP3)), 258),// Shows the current amount of funding, if applicable.
    STORE_TEMP(GetBankFunding()/GetBankFunding()*STORE_TEMP(LOAD_TEMP(1),1),259),
    STORE_TEMP(((GetBankConsumption()*100)/(param_bank_bonus_req/8) | (production_level*128/100) << 16),260),                                                    // Shows current consumption rate
    STORE_TEMP(hasbit(param_town_bonus_enabled,0) ? (((param_tips_enabled && production_level < 32) ? string(STR_IND_SEC_BANK_BONUST) : string(STR_IND_SEC_BANK_BONUS)) | ((GetTownProductionBonus()*param_temp_bank_town_bonus_mult)/100) << 16) : string(STR_SKIP),261),  // Shows current town production bonus
    STORE_TEMP(string(STR_IND_SEC_BONUS),256)                                                                               // String for bank bonus
]) {return string(STR_IND_SEC_TEMP_BANK_TOTAL);}

// This does production changes based of primary industry rules, but with its own twist since obviously it doesn't have any reserves and is incapable of closing no matter what happens.
switch(FEAT_INDUSTRIES, SELF, switch_production_change_temperate_bank, [STORE_TEMP(transported_last_month_pct("VALU"),0),STORE_TEMP(bank_is_active(),1)]) {
    return ((bank_is_active() == 0) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_prim_change_chance >= getbits(extra_callback_info2, 0, 7)) ?
    ((param_smooth_prim_growth == 1) ?
    ((param_prim_growth_diff == 0) ?
    switch_production_change_spec_easy()
    : (param_prim_growth_diff == 1) ?
    switch_production_change_spec_normal()
    : switch_production_change_spec_hard())
    : CB_RESULT_IND_PROD_RANDOM)
    : CB_RESULT_IND_PROD_NO_CHANGE);
}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_temperate_bank, [getbits(extra_callback_info2, 0, 8)]) {
    10: return incoming_cargo_waiting("VALU") <= GetBankStockpile();
}

// Seperated from the produce statement for additional logic to take place.
switch(FEAT_INDUSTRIES, PARENT, switch_produce_temperate_bank, [
    STORE_TEMP(GetBankConsumption(),0),
    STORE_TEMP(1+((GetBaseProduction()*(100+((GetTownProductionBonus()*param_temp_bank_town_bonus_mult)/100)))/100),3),
    param_bank_bonus_advanced ? STORE_PERM(LOAD_PERM(6)+GetBankConsumption()*2,6) : STORE_TEMP(0x00,19),
    STORE_PERM(BankBonus(),1)
]) {produce_temperate_bank;}

// Main item block.
item(FEAT_INDUSTRIES, temperate_bank, INDUSTRYTYPE_TEMPERATE_BANK) {
    property {
        substitute: INDUSTRYTYPE_TEMPERATE_BANK;
        override: INDUSTRYTYPE_TEMPERATE_BANK;
        cargo_types: [
            produce_cargo("VALU", 0),
            accept_cargo("VALU")
        ];
    }

    graphics {
        extra_text_industry: switch_production_display_temp_bank;
        cargo_subtype_display: CB_RESULT_NO_TEXT;
        produce_256_ticks: switch_produce_temperate_bank;
        monthly_prod_change: switch_production_change_temperate_bank;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
    stop_accept_cargo: switch_stop_accept_temperate_bank;
        build_prod_change: 16;
    }
}

/* POWER PLANT */

// Code adapted from 2TallTyler's improved town industries 1.0

spritelayout spr_layout_power_plant_1 {
    ground   {sprite: 2022;}
    building {sprite: 2050;}
}

spritelayout spr_layout_power_plant_2 {
    ground   {sprite: 2022;}

    building {sprite: 2053;}
}

spritelayout spr_layout_power_plant_3 {
    ground   {sprite: 2022;}
    building {sprite: 2054; yoffset: 2;}
}

spritelayout spr_layout_power_plant_4 {
    ground   {sprite: 2022;}
    building {sprite: 2047;}
}

item(FEAT_INDUSTRYTILES, ind_tile_power_plant_1) {
    property {
        substitute: 08;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: spr_layout_power_plant_1;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_power_plant_2) {
    property {
        substitute: 09;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: spr_layout_power_plant_2;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_power_plant_3) {
    property {
        substitute: 10;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: spr_layout_power_plant_3;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_power_plant_4) {
    property {
        substitute: 07;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: spr_layout_power_plant_4;
    }
}

tilelayout industry_layout_power_plant_1 {
    0,0: ind_tile_power_plant_4; 0,1: ind_tile_power_plant_4;
    1,0: ind_tile_power_plant_2; 1,1: ind_tile_power_plant_1;
    2,0: ind_tile_power_plant_3; 2,1: ind_tile_power_plant_2;
}

tilelayout industry_layout_power_plant_2 {
    2,0: ind_tile_power_plant_2; 2,1: ind_tile_power_plant_3; 2,2: ind_tile_power_plant_2;
    1,0: ind_tile_power_plant_1; 1,1: ind_tile_power_plant_1; 1,2: ind_tile_power_plant_4;
                                 0,1: ind_tile_power_plant_4; 0,2: ind_tile_power_plant_4;
}

tilelayout industry_layout_power_plant_3 {
    0,0: ind_tile_power_plant_4; 0,1: ind_tile_power_plant_2;
    1,0: ind_tile_power_plant_4; 1,1: ind_tile_power_plant_1;
    2,0: ind_tile_power_plant_4; 2,1: ind_tile_power_plant_1;
    3,0: ind_tile_power_plant_3; 3,1: ind_tile_power_plant_3;
}

produce (produce_power_plant,
    [COAL: LOAD_TEMP(0); PETR: LOAD_TEMP(6);],
    [],
    0
)

// Power plant consumption, based on waiting cargo.
switch(FEAT_INDUSTRIES, SELF, GetPowerPlantConsumption, max((min((incoming_cargo_waiting("COAL")*10000)/(param_power_cargo_req*param_power_stockpile_mult),100)*param_power_cargo_req/100/8),(incoming_cargo_waiting("COAL") > 0))) {return;}

// Power plant maximum stockpile (before cargo stops being accepted
switch(FEAT_INDUSTRIES, SELF, GetPowerPlantCoalStockpile, (param_power_cargo_req*param_power_stockpile_mult)/100) {return;}

switch(FEAT_INDUSTRIES, SELF, GetPowerPlantPetrolStockpile, (param_power_cargo_req*param_petrol_cons*param_power_stockpile_mult)/10000) {return;}

// Petrol consumption
switch(FEAT_INDUSTRIES, SELF, GetPowerPlantPetrolCons, (max((GetPowerPlantConsumption()*param_petrol_cons)/100,1)*(GetPowerPlantCoalStockpile() > 0))) {return;}

// Conversion Efficiency
switch(FEAT_INDUSTRIES, SELF, GetPowerPlantConversionEff, 100+min((((incoming_cargo_waiting("PETR")*100)/GetPowerPlantPetrolStockpile())*param_petrol_bonus)/100,param_petrol_bonus)) {return;}

// Like the bank bonus, this is based on either waiting cargo in basic power or waiting power units in advanced mode.
switch(FEAT_INDUSTRIES, SELF, GetPowerBonus, param_power_enabled > 0 ?
    param_power_advanced ? ((param_power_soft_cap == 1) && (STORE_TEMP(LOAD_TEMP(1),1) > (((param_power_cargo_req*param_power_stockpile_mult)/100))) ?
    (STORE_TEMP(LOAD_TEMP(1),1)/(200000/5)):0x00)+min(((STORE_TEMP(LOAD_TEMP(1),1)*100/param_power_cargo_req*100/param_power_stockpile_mult)*param_power_max_bonus)/100,param_power_max_bonus) : ((incoming_cargo_waiting("COAL")*10000)/(param_power_cargo_req*param_power_stockpile_mult)*param_power_max_bonus)/100 :
    0x00)
{return;}

// again idk why this is seperated but i know it is for a reason
switch(FEAT_INDUSTRIES, PARENT, PowerBonus, GetPowerUnits()) {GetPowerBonus;}

// This works exactly the same as the bank display but without the production display and power stats instead
switch(FEAT_INDUSTRIES, SELF, switch_production_display_power_plant, [
    STORE_TEMP(PowerBonus() | (param_power_enabled > 0 ?                                                             // Shows the current bonus provided by the power plant.
    (param_power_enabled == 1 ? string(STR_IND_SEC_BONUS_PRIM) : (param_power_enabled == 2 ?
    string(STR_IND_SEC_BONUS_SEC) : string(STR_EMPTY))): string(STR_EMPTY)) << 16, 257),                                    // Power bonus display (either primary, secondary, or none)
    STORE_TEMP((param_power_advanced ? string(STR_IND_SEC_POWER_STOCK) : string(STR_SKIP3)), 258),                  // Shows the current amount of power, if applicable.

    STORE_TEMP(GetPowerUnits()/GetPowerUnits()*STORE_TEMP(LOAD_TEMP(1),1),259),
    STORE_TEMP(((GetPowerPlantConsumption()*100)/(param_power_cargo_req/8)),260),                                                    // Shows current consumption rate
    STORE_TEMP(((param_tips_enabled && GetPowerPlantConversionEff() < 100+(param_petrol_bonus/4)) ? string(STR_IND_SEC_POWER_CONT) : string(STR_IND_SEC_POWER_CON)) | GetPowerPlantConversionEff() << 16,261),
    STORE_TEMP(string(STR_IND_SEC_BONUS),256)                                                                               // String for bonus
]) {return string(STR_IND_SEC_POWER_TOTAL);}

// Seperated for additional logic. Mostly adding power and updating the power bonus when doing a production tick. 
switch(FEAT_INDUSTRIES, PARENT, switch_produce_power_plant, [
    STORE_TEMP((GetPowerPlantConsumption()*100)/GetPowerPlantConversionEff(),0),
    STORE_PERM((STORE_TEMP(GetPowerPlantPetrolCons(),6)),6),
    param_power_advanced ? STORE_PERM(LOAD_PERM(5)+GetPowerPlantConsumption()*2,5) : STORE_TEMP(0x00,19),
    STORE_PERM(PowerBonus(),0)
]) {produce_power_plant;}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_power_plant, [getbits(extra_callback_info2, 0, 8)]) {
    1: return incoming_cargo_waiting("COAL") <= GetPowerPlantCoalStockpile()*10;
    24: return incoming_cargo_waiting("PETR") <= GetPowerPlantPetrolStockpile()*10;
}

// Main item block.
item(FEAT_INDUSTRIES, power_plant, INDUSTRYTYPE_POWER_PLANT) {
    property {
        substitute: INDUSTRYTYPE_POWER_PLANT;
        override: INDUSTRYTYPE_POWER_PLANT;
        cargo_types: [
            accept_cargo("COAL"),
        accept_cargo("PETR")
        ];
    layouts: [
            industry_layout_power_plant_1,
        industry_layout_power_plant_2,
        industry_layout_power_plant_3
    ];
    }

    graphics {
        extra_text_industry: switch_production_display_power_plant;
        cargo_subtype_display: CB_RESULT_NO_TEXT;
        produce_256_ticks: switch_produce_power_plant;
        monthly_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
    stop_accept_cargo: switch_stop_accept_power_plant;
        build_prod_change: 16;
    }
}

// STEEL MILL
// Ratio of steel is 1 units iron and 0.5 unit coal to 1 units steel.
// We simuulate this ratio in production_helper

// For all secondaries, they have to have a couple values stored in their registers for TotalSecondaryProduction() to function correctly.
// Register 0 is the stockpile modifier.

spritelayout spr_layout_steel_mill_1_N {
    ground   {sprite:2118;}
    building {sprite:2119;}
}

spritelayout spr_layout_steel_mill_1_E {
    ground   {sprite:2120;}
    building {sprite:2121;}
}

spritelayout spr_layout_steel_mill_1_W {
    ground   {sprite:2122;}
    building {sprite:2123;}
}

spritelayout spr_layout_steel_mill_1_S {
    ground   {sprite:2124;}
}

spritelayout spr_layout_steel_mill_2_N {
    ground   {sprite:2125;}
    building {sprite:2126;}
}

spritelayout spr_layout_steel_mill_2_W {
    ground   {sprite:2127;}
    building {sprite:2128;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_1_N) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_1_N;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_1_E) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_1_E;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_1_W) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_1_W;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_1_S) {
    property {

        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_1_S;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_2_N) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_2_N;}
}

item (FEAT_INDUSTRYTILES, ind_tile_steel_mill_2_W) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics { default: spr_layout_steel_mill_2_W;}
}

tilelayout industry_layout_steel_mill_1 {
    0,0: ind_tile_steel_mill_2_N; 0,1: ind_tile_steel_mill_2_N; 0,2: ind_tile_steel_mill_2_N;
    1,0: ind_tile_steel_mill_2_W; 1,1: ind_tile_steel_mill_2_W; 1,2: ind_tile_steel_mill_2_W;
    2,0: ind_tile_steel_mill_2_N; 2,1: ind_tile_steel_mill_1_N; 2,2: ind_tile_steel_mill_1_E;
    3,0: ind_tile_steel_mill_2_W; 3,1: ind_tile_steel_mill_1_W; 3,2: ind_tile_steel_mill_1_S;
}

tilelayout industry_layout_steel_mill_2 {
    0,0: ind_tile_steel_mill_1_N; 0,1: ind_tile_steel_mill_1_E; 0,2: ind_tile_steel_mill_2_N;
    1,0: ind_tile_steel_mill_1_W; 1,1: ind_tile_steel_mill_1_S; 1,2: ind_tile_steel_mill_2_W; 1,3: ind_tile_steel_mill_2_N;
    2,0: ind_tile_steel_mill_1_N; 2,1: ind_tile_steel_mill_1_E; 2,2: ind_tile_steel_mill_2_N; 2,3: ind_tile_steel_mill_2_W;
    3,0: ind_tile_steel_mill_1_W; 3,1: ind_tile_steel_mill_1_S; 3,2: ind_tile_steel_mill_2_W;
}

produce(produce_steel_mill,
    [COAL: (LOAD_TEMP(0)/2); IORE: LOAD_TEMP(0);],
    [STEL: LOAD_TEMP(0);],
    0
)

switch(FEAT_INDUSTRIES, SELF, steel_mill_max_stockpile_iron, min((GetMaxSecondaryProduction()*8*param_sec_max_stockpile_perc)/100,50000))  {return;}

// Divided by 2 since we consume coal at half the rate and thus is half as big for stockpile
switch(FEAT_INDUSTRIES, SELF, steel_mill_max_stockpile_coal, min((GetMaxSecondaryProduction()*4*param_sec_max_stockpile_perc)/100,50000)) {return;}

switch(FEAT_INDUSTRIES, SELF, steel_mill_stockpile_modifier, STORE_PERM(min(min((incoming_cargo_waiting("IORE")*100)/steel_mill_max_stockpile_iron(),(incoming_cargo_waiting("COAL")*100)/steel_mill_max_stockpile_coal()),100),0)) {return;}

switch(FEAT_INDUSTRIES, SELF, steel_mill_is_active, (steel_mill_stockpile_modifier() > 0)) {return;}

switch(FEAT_INDUSTRIES, PARENT, switch_production_steel_mill,
    // Consume funding if enabled and the industry benefits from it.
    [
    param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(steel_mill_is_active()*IsSecondaryPowered() ? (hasbit(param_bank_bonus_enabled,1)*GetFundingConsumptionSec()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(steel_mill_is_active()*IsSecondaryPowered() ? (hasbit(param_power_enabled,1)*GetPowerConsumptionSec()) : 0x00),5)) : 0x00,
    // Calculate production, but production is always zero if power plant doesn't have power (and secondaries require it).
     STORE_TEMP((min(min(GetTotalSecondaryProduction(),LOAD_TEMP(1)),LOAD_TEMP(2))+((LOAD_TEMP(1)>0)*(LOAD_TEMP(2)>0)))*IsSecondaryPowered(),0) 
    ])
    {produce_steel_mill;}

switch(FEAT_INDUSTRIES, SELF, switch_production_helper_steel_mill, [
    STORE_TEMP(incoming_cargo_waiting("IORE"),1),
    STORE_TEMP(incoming_cargo_waiting("COAL"),2),
    steel_mill_stockpile_modifier()
]) {switch_production_steel_mill;}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_steel_mill, [steel_mill_stockpile_modifier(),getbits(extra_callback_info2, 0, 8)]) {
    1: return incoming_cargo_waiting("COAL") <= steel_mill_max_stockpile_coal()*10;
    8: return incoming_cargo_waiting("IORE") <= steel_mill_max_stockpile_iron()*10;
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_steel_mill, [STORE_TEMP(transported_last_month_pct("STEL"),0),STORE_TEMP(steel_mill_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_sec_unserviced_freeze == 3 && (steel_mill_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_sec_grow_prob >= getbits(extra_callback_info2, 0, 7)*(((param_sec_unserviced_freeze >= 1) && (steel_mill_is_active() == 0))+(1+(hasbit(param_sec_unserviced_freeze,1)*(steel_mill_is_active() == 0))))) ? ((param_sec_advanced == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_sec_growth_diff == 0) ? switch_production_change_sec_easy() : ((param_sec_growth_diff == 1) ? switch_production_change_sec_normal() : switch_production_change_sec_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_NO_CHANGE)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : CB_RESULT_IND_PROD_NO_CHANGE;
}

switch(FEAT_INDUSTRIES, SELF, switch_display_steel_mill, param_tips_enabled && steel_mill_stockpile_modifier() < 25) {
    0: return switch_production_display_secondary_composite();
    1: return switch_production_display_secondary_composite_tips();
}

switch(FEAT_INDUSTRIES, SELF, switch_display_helper_steel_mill, IsSecondaryPowered()) {
    0: return string(STR_IND_SEC_PROD_DISABLED);
    1: return switch_display_steel_mill();
}

item(FEAT_INDUSTRIES, steel_mill, INDUSTRYTYPE_STEEL_MILL) {
    property {
        substitute: INDUSTRYTYPE_STEEL_MILL;
        override: INDUSTRYTYPE_STEEL_MILL;
        cargo_types: [
            produce_cargo("STEL", 0),
        accept_cargo("COAL"),
        accept_cargo("IORE")
        ];
    layouts: [industry_layout_steel_mill_1, industry_layout_steel_mill_2];
    }

    graphics {
        extra_text_industry: switch_display_helper_steel_mill;
        produce_256_ticks: switch_production_helper_steel_mill;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_steel_mill;
    stop_accept_cargo: switch_stop_accept_steel_mill;
        build_prod_change: random_initial_production;
    }
}

// TEMPERATE FACTORY
// This industry is special in that it's cargo agnostic and doesn't require all cargoes in order to function.
// 1 unit of input corresponds to 2 units of output. the stockpile modifier is still calculated as normal but it's no longer clamped to the cargo with the lowest value, each cargo contributes 25% to the overall modifier.

// Tile and sprite layout code adapted from 2TallTyler

spritelayout sprite_layout_factory_1_N {
    ground   {sprite:2146;}
    building {sprite:2150;}
}

spritelayout sprite_layout_factory_1_E {
    ground   {sprite:2147;}
    building {sprite:2151;}
}

spritelayout sprite_layout_factory_1_W {
    ground   {sprite:2148;}
    building {sprite:2152;}
}

spritelayout sprite_layout_factory_1_S {
    ground   {sprite:2149;}
}

item(FEAT_INDUSTRYTILES, ind_tile_factory_1_N) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: sprite_layout_factory_1_N;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_factory_1_E) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: sprite_layout_factory_1_E;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_factory_1_W) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: sprite_layout_factory_1_W;
    }
}

item(FEAT_INDUSTRYTILES, ind_tile_factory_1_S) {
    property {
        substitute: 02;
    special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        default: sprite_layout_factory_1_S;
    }
}

tilelayout industry_layout_temp_factory_1 {
    0,0: ind_tile_factory_1_N; 0,1: ind_tile_factory_1_E; 0,2: ind_tile_factory_1_N; 0,3: ind_tile_factory_1_E;
    1,0: ind_tile_factory_1_W; 1,1: ind_tile_factory_1_S; 1,2: ind_tile_factory_1_W; 1,3: ind_tile_factory_1_S;
                               2,1: ind_tile_factory_1_N; 2,2: ind_tile_factory_1_E;
                               3,1: ind_tile_factory_1_W; 3,2: ind_tile_factory_1_S;
}

tilelayout industry_layout_temp_factory_2 {
    0,0: ind_tile_factory_1_N; 0,1: ind_tile_factory_1_E;
    1,0: ind_tile_factory_1_W; 1,1: ind_tile_factory_1_S; 1,2: ind_tile_factory_1_N; 1,3: ind_tile_factory_1_E;
    2,0: ind_tile_factory_1_N; 2,1: ind_tile_factory_1_E; 2,2: ind_tile_factory_1_W; 2,3: ind_tile_factory_1_S;
    3,0: ind_tile_factory_1_W; 3,1: ind_tile_factory_1_S;
}

switch(FEAT_INDUSTRIES, SELF, temp_factory_max_stockpile, min((GetMaxSecondaryProduction()*8*param_sec_max_stockpile_perc)/100,50000))  {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_stockpile_modifier_steel, min((incoming_cargo_waiting("STEL")*100)/temp_factory_max_stockpile(),100)) {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_stockpile_modifier_livestock, min((incoming_cargo_waiting("LVST")*100)/temp_factory_max_stockpile(),100)) {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_stockpile_modifier_grain, min((incoming_cargo_waiting("GRAI")*100)/temp_factory_max_stockpile(),100)) {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_stockpile_modifier_lumber, min((incoming_cargo_waiting("LMBR")*100)/temp_factory_max_stockpile(),100)) {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_stockpile_modifier, STORE_PERM(min(temp_factory_stockpile_modifier_steel()/4+temp_factory_stockpile_modifier_livestock()/4+temp_factory_stockpile_modifier_grain()/4+temp_factory_stockpile_modifier_lumber()/4,100),0)) {return;}

switch(FEAT_INDUSTRIES, SELF, temp_factory_is_active, (temp_factory_stockpile_modifier() > 0)) {return;}

switch(FEAT_INDUSTRIES, SELF, GetTempFactoryLubricantStockpile, (temp_factory_max_stockpile()*param_lubricant_cons)/100) {return;}

// Petrol consumption
switch(FEAT_INDUSTRIES, SELF, GetTempFactoryLubricantCons, ((((GetBaseConversion()*temp_factory_stockpile_modifier())/100*param_lubricant_cons)/100)+(incoming_cargo_waiting("LUBR") > 0)*(temp_factory_stockpile_modifier() > 0))) {return;}

// Conversion Efficiency
switch(FEAT_INDUSTRIES, SELF, GetTempFactoryConversionEff, 100+min((((incoming_cargo_waiting("LUBR")*100)/GetTempFactoryLubricantStockpile())*param_lubricant_bonus)/100,param_lubricant_bonus)) {return;}

produce(produce_temp_factory,
    [STEL: (LOAD_TEMP(0)); LVST: LOAD_TEMP(1); GRAI: LOAD_TEMP(2); LMBR: LOAD_TEMP(3); LUBR: LOAD_TEMP(4);],
    [GOOD: (2*(LOAD_TEMP(0)+LOAD_TEMP(1)+LOAD_TEMP(2)+LOAD_TEMP(3))*GetTempFactoryConversionEff())/100;],
    0
)

// Because the factory is cargo agnostic, each input cargo may be consumed at a different rate, according to its stockpile modifier.
switch(FEAT_INDUSTRIES, PARENT, switch_production_temp_factory,
    // Consume funding if enabled and the industry benefits from it.
    [
    param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(temp_factory_is_active()*IsSecondaryPowered() ? (hasbit(param_bank_bonus_enabled,1)*GetFundingConsumptionSec()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(temp_factory_is_active()*IsSecondaryPowered() ? (hasbit(param_power_enabled,1)*GetPowerConsumptionSec()) : 0x00),5)) : 0x00,
    ])
    {produce_temp_factory;}

switch(FEAT_INDUSTRIES, SELF, switch_production_helper_temp_factory, [
    // Each cargo has its own stockpile modifier and so is calculated individually.
    // STEEL
    STORE_PERM(temp_factory_stockpile_modifier_steel(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("STEL"))+(incoming_cargo_waiting("STEL")>0))*IsSecondaryPowered(),0),
    // LIVESTOCK
    STORE_PERM(temp_factory_stockpile_modifier_livestock(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("LVST"))+(incoming_cargo_waiting("LVST")>0))*IsSecondaryPowered(),1),
    // GRAIN
    STORE_PERM(temp_factory_stockpile_modifier_grain(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("GRAI"))+(incoming_cargo_waiting("GRAI")>0))*IsSecondaryPowered(),2),
    // LUMBER
    STORE_PERM(temp_factory_stockpile_modifier_lumber(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("LMBR"))+(incoming_cargo_waiting("LMBR")>0))*IsSecondaryPowered(),3),
    // LUBRICANTS
    STORE_TEMP((min(GetTempFactoryLubricantCons(),incoming_cargo_waiting("LUBR")))*IsSecondaryPowered(),4),
    temp_factory_stockpile_modifier()
]) {switch_production_temp_factory;}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_temp_factory_composite, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    // Don't bother implementing tips into secondaries. huge waste of time. took hours for it to just not work. don't. seriously.
    STORE_TEMP(GetSecondaryProductionPerc() | GetTempFactoryConversionEff() << 16,261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)                                                                                                                                               
    ]) {
    return string(STR_IND_SEC_PROD_FACT);
}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_temp_factory_composite_tip1, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    // Don't bother implementing tips into secondaries. huge waste of time. took hours for it to just not work. don't. seriously.
    STORE_TEMP(GetSecondaryProductionPerc() | GetTempFactoryConversionEff() << 16,261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)                                                                                                                                               
    ]) {
    return string(STR_IND_SEC_PROD_FACTT1);
}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_temp_factory_composite_tip2, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    // Don't bother implementing tips into secondaries. huge waste of time. took hours for it to just not work. don't. seriously.
    STORE_TEMP(GetSecondaryProductionPerc() | GetTempFactoryConversionEff() << 16,261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)                                                                                                                                               
    ]) {
    return string(STR_IND_SEC_PROD_FACTT2);
}

switch(FEAT_INDUSTRIES, SELF, switch_production_display_temp_factory_composite_tip3, [
    // If enabled, display the power bonus and its accompanying text. If disabled, it shows a skip string which causes the string pointer to skip to the correct spot to read the next register (this goes for all optional mechanics)
    STORE_TEMP(GetStockpileModifier(),257),
    // If enabled, display the bank bonus and its accompanying text.
    STORE_TEMP((hasbit(param_power_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetPowerProductionBonus() < param_power_max_bonus/4 ? string(STR_IND_SEC_PROD_POWERT) : string(STR_IND_SEC_PROD_POWER)) | GetPowerProductionBonus() << 16 : string(STR_SKIP),258),
    // If enabled, display the town bonus and its accompanying text.
    STORE_TEMP((hasbit(param_bank_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetBankProductionBonus() < param_bank_max_bonus/4 ? string(STR_IND_SEC_PROD_BANKT) : string(STR_IND_SEC_PROD_BANK)) | GetBankProductionBonus() << 16 : string(STR_SKIP),259),
    // For compression's sake, register 260 both stores the primary production percentage and the necessary text for reserves, if necessary.
    STORE_TEMP((hasbit(param_town_bonus_enabled,1) && hasbit(param_ind_detailed_enabled,0)) ? (param_tips_enabled && GetTownProductionBonus() < param_town_max_bonus/5 ? string(STR_IND_SEC_PROD_TOWNT) : string(STR_IND_SEC_PROD_TOWN)) | GetTownProductionBonus() << 16 : string(STR_SKIP),260),

    // Don't bother implementing tips into secondaries. huge waste of time. took hours for it to just not work. don't. seriously.
    STORE_TEMP(GetSecondaryProductionPerc() | GetTempFactoryConversionEff() << 16,261),
    // So initial base production (normally at the top of the window) is here because register 256 is wiped when accessing town storage. This is also why it's split into two different statements.
    STORE_PERM(GetBaseProductionPerc(),16),
    STORE_TEMP(param_sec_advanced == 1 ? (param_tips_enabled && production_level < 32 ? string(STR_IND_SEC_PROD_BASET) : string(STR_IND_SEC_PROD_BASE)) | GetBaseProductionPerc() << 16 : string(STR_SKIP),18),
    STORE_TEMP(LOAD_TEMP(18),256)                                                                                                                                               
    ]) {
    return string(STR_IND_SEC_PROD_FACTT3);
}

switch(FEAT_INDUSTRIES, SELF, switch_display_temp_factory, (param_tips_enabled && GetTempFactoryConversionEff() < 100+(param_lubricant_bonus/4)) | (param_tips_enabled && temp_factory_stockpile_modifier() < 10) << 1) {
    0: return switch_production_display_temp_factory_composite();
    1: return switch_production_display_temp_factory_composite_tip1();
    2: return switch_production_display_temp_factory_composite_tip2();
    3: return switch_production_display_temp_factory_composite_tip3();
}

switch(FEAT_INDUSTRIES, SELF, switch_display_helper_temp_factory, IsSecondaryPowered()) {
    0: return string(STR_IND_SEC_PROD_DISABLED);
    1: return switch_display_temp_factory();
}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_temp_factory, [STORE_TEMP(transported_last_month_pct("GOOD"),0),STORE_TEMP(temp_factory_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_sec_unserviced_freeze == 3 && (temp_factory_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_sec_grow_prob >= getbits(extra_callback_info2, 0, 7)*(((param_sec_unserviced_freeze >= 1) && (temp_factory_is_active() == 0))+(1+(hasbit(param_sec_unserviced_freeze,1)*(temp_factory_is_active() == 0))))) ? ((param_sec_advanced == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_sec_growth_diff == 0) ? switch_production_change_sec_easy() : ((param_sec_growth_diff == 1) ? switch_production_change_sec_normal() : switch_production_change_sec_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_NO_CHANGE)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : CB_RESULT_IND_PROD_NO_CHANGE;
}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_temp_factory, [temp_factory_stockpile_modifier(),getbits(extra_callback_info2, 0, 8)]) {
    4: return incoming_cargo_waiting("LVST") <= temp_factory_max_stockpile()*10;
    6: return incoming_cargo_waiting("GRAI") <= temp_factory_max_stockpile()*10;
    9: return incoming_cargo_waiting("STEL") <= temp_factory_max_stockpile()*10;
    21: return incoming_cargo_waiting("LMBR") <= temp_factory_max_stockpile()*10;
    23: return incoming_cargo_waiting("LUBR") <= GetTempFactoryLubricantStockpile()*10;
}

item(FEAT_INDUSTRIES, temperate_factory, INDUSTRYTYPE_TEMPERATE_FACTORY) {
    property {
        substitute: INDUSTRYTYPE_TEMPERATE_FACTORY;
        override: INDUSTRYTYPE_TEMPERATE_FACTORY;
    spec_flags: bitmask(IND_FLAG_LONG_CARGO_TYPE_LISTS);
        cargo_types: [
            produce_cargo("GOOD", 0),
        accept_cargo("STEL"),
        accept_cargo("LVST"),
        accept_cargo("GRAI"),
        accept_cargo("LMBR"),
        accept_cargo("LUBR")
        ];
    layouts: [industry_layout_temp_factory_1, industry_layout_temp_factory_2];
    }

    graphics {
        extra_text_industry: switch_display_helper_temp_factory;
        produce_256_ticks: switch_production_helper_temp_factory;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_temp_factory;
    stop_accept_cargo: switch_stop_accept_temp_factory;
    cargo_subtype_display: CB_RESULT_NO_TEXT;
        build_prod_change: random_initial_production;
    }
}

// OIL REFINERY
// This is essentially a second hub, focused moreso on productivity increases for the rest of your network rather than pure goods.
// 1 Input = 0.5 Goods, 0.25 petrol, 0.25 lubricants

produce(produce_oil_refinery,
    [OIL_: LOAD_TEMP(0);],
    [GOOD: LOAD_TEMP(0)/2; PETR: LOAD_TEMP(0)/4; LUBR: LOAD_TEMP(0)/4;],
    0
)

switch(FEAT_INDUSTRIES, SELF, oil_refinery_max_stockpile, min((GetMaxSecondaryProduction()*8*param_sec_max_stockpile_perc)/100,50000))  {return;}

switch(FEAT_INDUSTRIES, SELF, oil_refinery_stockpile_modifier, STORE_PERM(min((incoming_cargo_waiting("OIL_")*100)/oil_refinery_max_stockpile(),100),0)) {return;}

switch(FEAT_INDUSTRIES, SELF, oil_refinery_is_active, oil_refinery_stockpile_modifier() > 0) {return;}

// Because the factory is cargo agnostic, each input cargo may be consumed at a different rate, according to its stockpile modifier.
switch(FEAT_INDUSTRIES, PARENT, switch_production_oil_refinery,
    // Consume funding if enabled and the industry benefits from it.
    [
    param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(oil_refinery_is_active()*IsSecondaryPowered() ? (hasbit(param_bank_bonus_enabled,1)*GetFundingConsumptionSec()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(oil_refinery_is_active()*IsSecondaryPowered() ? (hasbit(param_power_enabled,1)*GetPowerConsumptionSec()) : 0x00),5)) : 0x00,
    ])
    {produce_oil_refinery;}

switch(FEAT_INDUSTRIES, SELF, switch_production_helper_oil_refinery, [
    STORE_PERM(oil_refinery_stockpile_modifier(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("OIL_"))+((incoming_cargo_waiting("OIL_")>0)*4))*IsSecondaryPowered(),0),
    oil_refinery_stockpile_modifier()
]) {switch_production_oil_refinery;}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_oil_refinery, STORE_TEMP(((transported_last_month_pct("GOOD")/2)+(transported_last_month_pct("PETR")/4)+(transported_last_month_pct("LUBR")/4)),0)) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_sec_unserviced_freeze == 3 && (oil_refinery_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_sec_grow_prob >= getbits(extra_callback_info2, 0, 7)*(((param_sec_unserviced_freeze >= 1) && (oil_refinery_is_active() == 0))+(1+(hasbit(param_sec_unserviced_freeze,1)*(oil_refinery_is_active() == 0))))) ? ((param_sec_advanced == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_sec_growth_diff == 0) ? switch_production_change_sec_easy() : ((param_sec_growth_diff == 1) ? switch_production_change_sec_normal() : switch_production_change_sec_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_NO_CHANGE)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : CB_RESULT_IND_PROD_NO_CHANGE;
}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_oil_refinery, [oil_refinery_stockpile_modifier(),getbits(extra_callback_info2, 0, 8)]) {
    3: return incoming_cargo_waiting("OIL_") <= oil_refinery_max_stockpile()*10;
}

switch(FEAT_INDUSTRIES, SELF, switch_display_oil_refinery, param_tips_enabled && oil_refinery_stockpile_modifier() < 25) {
    0: return switch_production_display_secondary_composite();
    1: return switch_production_display_secondary_composite_tips();
}

switch(FEAT_INDUSTRIES, SELF, switch_display_helper_oil_refinery, IsSecondaryPowered()) {
    0: return string(STR_IND_SEC_PROD_DISABLED);
    1: return switch_display_oil_refinery();
}

item(FEAT_INDUSTRIES, oil_refinery, INDUSTRYTYPE_OIL_REFINERY) {
    property {
        substitute: INDUSTRYTYPE_OIL_REFINERY;
        override: INDUSTRYTYPE_OIL_REFINERY;
        cargo_types: [
            produce_cargo("GOOD", 0),
        produce_cargo("PETR", 0),
        produce_cargo("LUBR",0),
        accept_cargo("OIL_")
        ];
    // layouts: [industry_layout_temp_factory_1];
    }

    graphics {
        extra_text_industry: switch_display_helper_oil_refinery;
        produce_256_ticks: switch_production_helper_oil_refinery;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_oil_refinery;
    stop_accept_cargo: switch_stop_accept_oil_refinery;
        build_prod_change: random_initial_production;
    }
}

// SAWMILL
// Similar to the steel mill, this mostly is a smaller secondary meant to feed into the factory.
// 1 Unit of input = 1 unit of output.

produce(produce_sawmill,
    [WOOD: (LOAD_TEMP(0));],
    [LMBR: (LOAD_TEMP(0));],
    0
)

switch(FEAT_INDUSTRIES, SELF, sawmill_max_stockpile, min((GetMaxSecondaryProduction()*8*param_sec_max_stockpile_perc)/100,50000))  {return;}

switch(FEAT_INDUSTRIES, SELF, sawmill_stockpile_modifier, STORE_PERM(min((incoming_cargo_waiting("WOOD")*100)/oil_refinery_max_stockpile(),100),0)) {return;}

switch(FEAT_INDUSTRIES, SELF, sawmill_is_active, sawmill_stockpile_modifier() > 0) {return;}

switch(FEAT_INDUSTRIES, PARENT, switch_production_sawmill,
    // Consume funding if enabled and the industry benefits from it.
    [
    param_bank_bonus_advanced ? (STORE_PERM(LOAD_PERM(6)-(sawmill_is_active()*IsSecondaryPowered() ? (hasbit(param_bank_bonus_enabled,1)*GetFundingConsumptionSec()) : 0x00),6)) : 0x00,
    // Consume power if enabled and the industry benefits from it.
     param_power_advanced ? (STORE_PERM(LOAD_PERM(5)-(sawmill_is_active()*IsSecondaryPowered() ? (hasbit(param_power_enabled,1)*GetPowerConsumptionSec()) : 0x00),5)) : 0x00,
    ])
    {produce_sawmill;}

switch(FEAT_INDUSTRIES, SELF, switch_production_helper_sawmill, [
    STORE_PERM(sawmill_stockpile_modifier(),0),
    STORE_TEMP((min(GetTotalSecondaryProduction(),incoming_cargo_waiting("WOOD"))+(incoming_cargo_waiting("WOOD")>0))*IsSecondaryPowered(),0),
    sawmill_stockpile_modifier()
]) {switch_production_sawmill;}

switch(FEAT_INDUSTRIES, SELF, switch_production_change_sawmill, [STORE_TEMP(transported_last_month_pct("LMBR"),0),STORE_TEMP(sawmill_is_active(),1)]) {
    // Check for smooth growth and determine whether a growth event can even happen
    return (param_sec_unserviced_freeze == 3 && (sawmill_is_active() == 0)) ? CB_RESULT_IND_PROD_NO_CHANGE :
    (param_sec_grow_prob >= getbits(extra_callback_info2, 0, 7)*(((param_sec_unserviced_freeze >= 1) && (sawmill_is_active() == 0))+(1+(hasbit(param_sec_unserviced_freeze,1)*(sawmill_is_active() == 0))))) ? ((param_sec_advanced == 1)
    // Do the correct change logic based on the set difficulty.
    ? ((param_sec_growth_diff == 0) ? switch_production_change_sec_easy() : ((param_sec_growth_diff == 1) ? switch_production_change_sec_normal() : switch_production_change_sec_hard()))
    // If smooth growth is disabled, a random change (vanilla) occurs instead
    : CB_RESULT_IND_PROD_NO_CHANGE)
    // If reserves are depleted, close. If growth chance failed, do no change.
    : CB_RESULT_IND_PROD_NO_CHANGE;
}

switch(FEAT_INDUSTRIES, SELF, switch_stop_accept_sawmill, [sawmill_stockpile_modifier(),getbits(extra_callback_info2, 0, 8)]) {
    7: return incoming_cargo_waiting("WOOD") <= sawmill_max_stockpile()*10;
}

switch(FEAT_INDUSTRIES, SELF, switch_display_sawmill, param_tips_enabled && sawmill_stockpile_modifier() < 25) {
    0: return switch_production_display_secondary_composite();
    1: return switch_production_display_secondary_composite_tips();
}

switch(FEAT_INDUSTRIES, SELF, switch_display_helper_sawmill, IsSecondaryPowered()) {
    0: return string(STR_IND_SEC_PROD_DISABLED);
    1: return switch_display_sawmill();
}

item(FEAT_INDUSTRIES, sawmill, INDUSTRYTYPE_SAWMILL) {
    property {
        substitute: INDUSTRYTYPE_SAWMILL;
        override: INDUSTRYTYPE_SAWMILL;
        cargo_types: [
            produce_cargo("LMBR", 0),
        accept_cargo("WOOD")
        ];
    // layouts: [industry_layout_temp_factory_1];
    }

    graphics {
        extra_text_industry: switch_display_helper_sawmill;
        produce_256_ticks: switch_production_helper_sawmill;
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: switch_production_change_sawmill;
    stop_accept_cargo: switch_stop_accept_sawmill;
        build_prod_change: random_initial_production;
    }
}
